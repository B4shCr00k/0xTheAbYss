[{"content":"what are imports basically imports are functions a pe needs to function properly, these functions are located inside dlls (dynamic link libraries) so first the executable needs to load the dll then find the functions he needs and get their addresses\nnow in order to know which functions an executable needs there is something called the IAT table which is a table inside the import directory in the pe structure, this table contains all the names of the functions the exe (or the dll) needs as well as their addresses\nwhen the exe first lunches the iat will be empty just names but no addresses so windows automatically reads this table, finds which dlls contains the functions, loads them using a function called LoadLibraryA() which will patch this table with then use something like GetProcAddress() to get the function addresses then patch the iat table with the correct addresses so the exe now works well\nWhat is Manual Loading instead of letting windows do all the stuff i just mentioned we do everything manually, Why? for a lot of reasons like windows uses high-level api functions like LoadLibraryA() or GetProcAddress() which in case the system has an edr installed will def be hooked therefore your malware will immedieatly gets detected to avoid this we manually patch the iat table\nhow is it done first of all since we are dealing with a pe you need to parse the pe and get the ntheader, this guide is about remotely resolving imports but in order to do so you would have to first write the pe into the target process with all the headers and sections\nso first of all\nget the import directory rva (relative virtual address) which is stored in ntHeader-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress where IMAGE_DIRECTORY_ENTRY_IMPORT is a macro for 1\nnext we need the import descriptor IMAGE_IMPORT_DESCRIPTOR it is located at the virtual address so in order to get it\n1 IMAGE_IMPORT_DESCRIPTOR* importDesc = (PIMAGE_IMPORT_DESCRIPTOR)(BaseAddress + ntHeader-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); next we start looping through every dll we use the condition while(importDesc-\u0026gt;Name) we first get the dll name which is stored in importDesc-\u0026gt;Name so const char* dllName = (char*)(BaseAddress + currentDesc-\u0026gt;Name); and then we load the library so we can get the functions inside it HMODULE dllHandle = LoadLibraryA(dllName); now we can access the dll what we need to do is read what fucntions the pe needs and get their addresses from the loaded dll we have originalThunk and firstThunk originalThunk : where the pe stores the function names it needs whether using names or ordinal firstThunk : where the pe stores the actual addresses of these functions and this is what we need to patch\nwe can read them both this way 1 2 PIMAGE_THUNK_DATA origThunk = (PIMAGE_THUNK_DATA)(BaseAddress + importDesc-\u0026gt;OriginalFirstThunk); PIMAGE_THUNK_DATA firstThunk = (PIMAGE_THUNK_DATA)(BaseAddress + importDesc-\u0026gt;FirstThunk); now we have addresses to them we start by getting the function names inside the originalthunk while(origThunk-\u0026gt;u1.AddressOfData) so there r two cases for functions whether we should import them by ordinal or by names lets start with ordinal\nwe do the following pick the origThunk-\u0026gt;u1.Ordinal and (and \u0026amp;) it with IMAGE_ORDINAL_FLAG64 which is 0x8000000000000000 in x64 what this does is check if the ordinal bit is set if true then we need to import by ordinal to do so we extract the ordinal by again using the \u0026amp; operator with the ordinal WORD ordinal = (WORD)(origThunk-\u0026gt;u1.Ordinal \u0026amp; 0xFFFF); this way we extract the ordinal only finally we get the address funcAddress = GetProcAddress(dllHandle, (LPCSTR)(uintptr_t)ordinal);\nnow for imports by name we need to first get the structure PIMAGE_IMPORT_BY_NAME importByName = (PIMAGE_IMPORT_BY_NAME)(BaseAddress + origThunk-\u0026gt;u1.AddressOfData); then we have the name char* funcName = (char*)importByName-\u0026gt;Name; all we need to do is get the address with funcAddress = GetProcAddress(dllHandle, funcName);\nfor the final step which we did all of this for we need to patch the iat table first we need its address first we calculate the offset using ULONGLONG offset = (BYTE*)firstThunk - (BYTE*)BaseAddress; this gives us the offset of the entry inside the iat table we can get this from our process since we have the offset we just add it to the remote base ULONGLONG remoteIATEntry = (ULONGLONG)RemoteAddress + offset; finally we path the iat table using WriteProcessMemmory()\nand thats it now the iat table is patched and the imports are resolved\nFULL CODE :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 if (ntHeader-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress != 0) { DWORD importRVA = ntHeader-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; DWORD importSize = ntHeader-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size; IMAGE_IMPORT_DESCRIPTOR* importDesc = (PIMAGE_IMPORT_DESCRIPTOR)(BaseAddress + ntHeader-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); SIZE_T descriptorSize = sizeof(IMAGE_IMPORT_DESCRIPTOR); PIMAGE_IMPORT_DESCRIPTOR currentDesc = importDesc; while (currentDesc-\u0026gt;Name) { const char* dllName = (char*)(BaseAddress + currentDesc-\u0026gt;Name); HMODULE dllHandle = GetModuleHandleA(dllName); if (!dllHandle) dllHandle = LoadLibraryA(dllName); PIMAGE_THUNK_DATA origThunk = (PIMAGE_THUNK_DATA)(BaseAddress + currentDesc-\u0026gt;OriginalFirstThunk); PIMAGE_THUNK_DATA firstThunk = (PIMAGE_THUNK_DATA)(BaseAddress + currentDesc-\u0026gt;FirstThunk); while (origThunk-\u0026gt;u1.AddressOfData) { FARPROC funcAddress = NULL; if (origThunk-\u0026gt;u1.Ordinal \u0026amp; IMAGE_ORDINAL_FLAG64) { WORD ordinal = (WORD)(origThunk-\u0026gt;u1.Ordinal \u0026amp; 0xFFFF); funcAddress = GetProcAddress(dllHandle, (LPCSTR)(uintptr_t)ordinal); } else { PIMAGE_IMPORT_BY_NAME importByName = (PIMAGE_IMPORT_BY_NAME)(BaseAddress + origThunk-\u0026gt;u1.AddressOfData); char* funcName = (char*)importByName-\u0026gt;Name; funcAddress = GetProcAddress(dllHandle, funcName); } ULONGLONG remoteIATEntry = (ULONGLONG)NewAddress + ((BYTE*)firstThunk - (BYTE*)BaseAddress); SIZE_T bytesWritten1 = 0; if (!WriteProcessMemory(pi.hProcess, (LPVOID)remoteIATEntry, \u0026amp;funcAddress, sizeof(funcAddress), \u0026amp;bytesWritten1)) { error(\u0026#34;Failed to write to remote IAT\u0026#34;); return -1; } origThunk++; firstThunk++; } currentDesc++; } } ","date":"2025-07-22T00:00:00Z","image":"https://B4shCr00k.github.io/0xTheAbYss/posts/resolving-imports-remotely/nice_hu_69704fb005500857.jpg","permalink":"https://B4shCr00k.github.io/0xTheAbYss/posts/resolving-imports-remotely/","title":"Resolving Imports Remotely"}]