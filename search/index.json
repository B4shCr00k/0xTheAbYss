[{"content":"Hello From Kernel In this guide i will help you write your first windows kernel driver using kmdf\nThis Guide Will Cover What are drivers\nPrerequisite\nUser Mode VS Kernel Mode\nCode WalkThrough\nCompiling and loading the driver\nWhat Are Drivers A driver is a piece of software that allows the operating system to communicate with hardware devices. In our case, we are developing what\u0026rsquo;s known as a software driver, a type of driver that facilitates communication between user mode and kernel mode, without necessarily interacting with physical hardware. These drivers are essential for tasks that require privileged access to system resources, such as monitoring, hooking, or custom control mechanisms.\nWhen it comes to malware and rootkits, drivers take on a more malicious role. In this context, a driver can be used to gain low-level access to the operating system, often bypassing security mechanisms like User Account Control (UAC) or antivirus protections. Kernel-mode drivers used by rootkits can hide files, processes, or registry keys, intercept system calls, and exert stealthy control over the systemâ€”making them one of the most powerful tools in advanced malware development.\nPrerequisite First of all you really don\u0026rsquo;t want to test drivers on your main (host) machine since any fatal mistake will make your system crash therefore having a testing environnement is so important i advice using a virtual machine you can use vmware (free version) or virtual box which is free as well\nonce you have the testing machine ready disable memory integrity options from the windows security settings then we need to enable test signing to do so run the following commands on an elevated cmd (run as administrator)\n1 2 bcdedit.exe -set loadoptions DISABLE_INTEGRITY_CHECKS bcdedit.exe -set TESTSIGNING ON you might get something like \u0026ldquo;The value is protected by Secure Boot policy and cannot be modified or deleted\u0026rdquo; in this case you have secure boot on you should go google how to disable secure boot for your machine usually from the bios\nnow we are done from setting up the testing machine lets set up the machine where we will be coding our diver, first you will need to install visual studio, sdk and wdk here is a guide by microsoft\nnext we can set up kernel debugging using windbg but its pretty complicated and unnecessary for now so we you can just download DebugView on the testing machine\nfinally we create a kmdf empty project using visual studio add a main.c under your source folder and delete the driver you will find under driver files since we dont need it\nUser Mode VS Kernel Mode for security, stability, and control reasons execution is split into two modes :\n\u0026mdash; user mode where normal programs like browsers games text editors run it cannot access memory used by the os and needs to call the os using high level api windows functions in order to do such things, programs in user mode has a private virtual memory meaning when a process runs it thinks it owns the entire memory to it self this is implemented for security reasons as well as other reasons read this for more infos on virtual memory\n\u0026mdash; kernel mode where the kernel itself, drivers and os programs run it can literally do anything in this system in kernel mode you have full access to hardware, memory and system resources all programs that run in kernel mode share the same virtual space meaning if something happens to one program it will crash the entire system leading to a BSOD or other fatal errors\ndrivers are like a bridge that allow us to run code in kernel space\nCode WalkThrough Now We will code a simple hello world from the kernel poc\nwe need to be very careful when coding drivers and we need to follow a spesific structure open main.c and lets start coding\nfirst we include #include \u0026lt;ntddk.h\u0026gt; which has everything we need to code our driver\nnext we define something called a tag which is used to track down memory allocations made by the driver we use this for debugging so we can easily know what driver allocated this memory space #define DRIVER_TAG 'gaT' first we write the name in reverse due to the little endian and use single quotes we also need to define a UNICODE_STRING which is a structure for unicode strings which a lot of low level functions need it has 3 fields length which is the size of the buffer in bytes and not null terminated MaximumLength which is the max size the buffer can hold buffer the actual unicode string so UNICODE_STRING g_RegPath;\nnext we define our entrypoint which is NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) the driverobject is a struct that holds all the important infos about our drivers it has things like DriverObject-\u0026gt;DriverUnload which is the code that will get executed once the driver is unloaded this struct is very important and is like a handle to control the driver, the registery path is a unicode string that has something like \u0026ldquo;\\Registry\\Machine\\System\\CurrentControlSet\\Services\\MyDriver\u0026rdquo; we will print it later\ninside our function we will be using something calledDbgPrint(); which is just like printf() in user mode this function will allow us to debug the driver using print statements we can later read using debugging tools, next we print the driverobject and the registerypath like this\n1 2 DbgPrint(\u0026#34;[+] Driver Object: %p\\n\u0026#34;, DriverObject); DbgPrint(\u0026#34;[+] Registry Path: %p\\n\u0026#34;, RegistryPath); next we will allocate space for our buffer to populate our g_RegPath unicode string struct we do this so can save the reg path for later use since its only save to access it i the DriverEntry only to do this we will get into memory allocation in kernel mode, there are more than one function to allocate space in kernel mode unlike use mode where we can use malloc we can use ExAllocatePool2() which is a new function used to allocate space in memory safely so g_RegPath.Buffer = (PWSTR)ExAllocatePool2(POOL_FLAG_PAGED, RegistryPath-\u0026gt;Length, DRIVER_TAG) we are allocating space for our buffer and we store the pointer inside g_RegPath.Buffer the first argument is POOL_FLAG_PAGED read more about memory pools here next we can how many bytes we will allocate RegistryPath-\u0026gt;Length which is the length of the regpath buffer, finally we have the tag we will use for this memory space DRIVER_TAG which is Test in our case next we run a test to see if it the buffer is still null just like with malloc 1 2 3 4 5 if (g_RegPath.Buffer == NULL) { DbgPrint(\u0026#34;[-] Failed To Allocate Space For The Reg\u0026#34;); return STATUS_NO_MEMORY; } then we copy the registerypath from the param into our buffer using memcpy memcpy(g_RegPath.Buffer, RegistryPath-\u0026gt;Buffer, RegistryPath-\u0026gt;Length); also we set the length to same length g_RegPath.Length = g_RegPath.MaximumLength = RegistryPath-\u0026gt;Length; and finally we dbgprint a message DbgPrint(\u0026quot;Param Key Copy %wZ\\n\u0026quot;,g_RegPath)\nnow we need to set DriverObject-\u0026gt;DriverUnload into our unload function which will run when the driver unload DriverObject-\u0026gt;DriverUnload = UnloadMe so make sure you defined this function before the DriverEntry Function so the compiler can recognize it\nnow we code the actual UnloadMe function it takes one param which is the driverobject struct for now we will just free the allocated space which is something you should always do in kernel mode\n1 2 3 4 5 6 7 8 9 10 11 12 13 void UnloadMe(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrint(\u0026#34;[+] Driver unloaded successfully.\\n\u0026#34;); DbgPrint(\u0026#34;[+] Driver Object: %p\\n\u0026#34;, DriverObject); if (g_RegPath.Buffer != NULL) { ExFreePool(g_RegPath.Buffer); g_RegPath.Buffer = NULL; } DbgPrint(\u0026#34;[+] Driver Unloaded\\n\u0026#34;); } we used ExFreePool(g_RegPath.Buffer); which is just like free() in um\nCompiling and loading the driver to build the project just build in visual studio and make sure you do so in debug mode or all the debug messages wont appear\nto install the driver we will use Service Controller (sc.exe) to do so we run this command sc create HelloWorldDriver type= kernel binPath= C:\\MyDrivers\\HelloWorldDriver.sys change the path into ur dirver\u0026rsquo;s path you can also change HelloWorldDriver into whatever name u want now open DebugView and enable all the kernel capture options under capture\nfinally we load the driver with sc start HelloWorldDriver or whatever name u chose you should see the messages appear in your DebugView interface if u dont its because you didnt enable the correct options under the capture tab to unload the driver we use sc stop HelloWorldDriver\nFULL CODE :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;ntddk.h\u0026gt; #define DRIVER_TAG \u0026#39;bdwh\u0026#39; UNICODE_STRING g_RegPath; void UnloadMe(PDRIVER_OBJECT); NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { DbgPrint(\u0026#34;[+] Driver loaded successfully.\\n\u0026#34;); DbgPrint(\u0026#34;[+] Driver Object: %p\\n\u0026#34;, DriverObject); DbgPrint(\u0026#34;[+] Registry Path: %p\\n\u0026#34;, RegistryPath); g_RegPath.Buffer = (PWSTR)ExAllocatePool2(POOL_FLAG_PAGED, RegistryPath-\u0026gt;Length, DRIVER_TAG); if (g_RegPath.Buffer == NULL) { DbgPrint(\u0026#34;[-] Failed To Allocate Space For The Reg\u0026#34;); return STATUS_NO_MEMORY; } memcpy(g_RegPath.Buffer, RegistryPath-\u0026gt;Buffer, RegistryPath-\u0026gt;Length); g_RegPath.Length = g_RegPath.MaximumLength = RegistryPath-\u0026gt;Length; DbgPrint(\u0026#34;Param Key Copy %wZ\\n\u0026#34;,g_RegPath); DriverObject-\u0026gt;DriverUnload = UnloadMe; return STATUS_SUCCESS; } void UnloadMe(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrint(\u0026#34;[+] Driver unloaded successfully.\\n\u0026#34;); DbgPrint(\u0026#34;[+] Driver Object: %p\\n\u0026#34;, DriverObject); if (g_RegPath.Buffer != NULL) { ExFreePool(g_RegPath.Buffer); g_RegPath.Buffer = NULL; } DbgPrint(\u0026#34;[+] Driver Unloaded\\n\u0026#34;); } ","date":"2025-07-26T00:00:00Z","image":"https://B4shCr00k.github.io/0xTheAbYss/posts/introduction-into-windows-kernel-drivers/raven_hu_3133004e57f6df76.jpg","permalink":"https://B4shCr00k.github.io/0xTheAbYss/posts/introduction-into-windows-kernel-drivers/","title":"Introduction Into Windows Kernel Drivers"},{"content":"what are imports basically imports are functions a pe needs to function properly, these functions are located inside dlls (dynamic link libraries) so first the executable needs to load the dll then find the functions he needs and get their addresses\nnow in order to know which functions an executable needs there is something called the IAT table which is a table inside the import directory in the pe structure, this table contains all the names of the functions the exe (or the dll) needs as well as their addresses\nwhen the exe first lunches the iat will be empty just names but no addresses so windows automatically reads this table, finds which dlls contains the functions, loads them using a function called LoadLibraryA() which will patch this table with then use something like GetProcAddress() to get the function addresses then patch the iat table with the correct addresses so the exe now works well\nWhat is Manual Loading instead of letting windows do all the stuff i just mentioned we do everything manually, Why? for a lot of reasons like windows uses high-level api functions like LoadLibraryA() or GetProcAddress() which in case the system has an edr installed will def be hooked therefore your malware will immedieatly gets detected to avoid this we manually patch the iat table\nhow is it done first of all since we are dealing with a pe you need to parse the pe and get the ntheader, this guide is about remotely resolving imports but in order to do so you would have to first write the pe into the target process with all the headers and sections\nso first of all\nget the import directory rva (relative virtual address) which is stored in ntHeader-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress where IMAGE_DIRECTORY_ENTRY_IMPORT is a macro for 1\nnext we need the import descriptor IMAGE_IMPORT_DESCRIPTOR it is located at the virtual address so in order to get it\n1 IMAGE_IMPORT_DESCRIPTOR* importDesc = (PIMAGE_IMPORT_DESCRIPTOR)(BaseAddress + ntHeader-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); next we start looping through every dll we use the condition while(importDesc-\u0026gt;Name) we first get the dll name which is stored in importDesc-\u0026gt;Name so const char* dllName = (char*)(BaseAddress + currentDesc-\u0026gt;Name); and then we load the library so we can get the functions inside it HMODULE dllHandle = LoadLibraryA(dllName); now we can access the dll what we need to do is read what fucntions the pe needs and get their addresses from the loaded dll we have originalThunk and firstThunk originalThunk : where the pe stores the function names it needs whether using names or ordinal firstThunk : where the pe stores the actual addresses of these functions and this is what we need to patch\nwe can read them both this way 1 2 PIMAGE_THUNK_DATA origThunk = (PIMAGE_THUNK_DATA)(BaseAddress + importDesc-\u0026gt;OriginalFirstThunk); PIMAGE_THUNK_DATA firstThunk = (PIMAGE_THUNK_DATA)(BaseAddress + importDesc-\u0026gt;FirstThunk); now we have addresses to them we start by getting the function names inside the originalthunk while(origThunk-\u0026gt;u1.AddressOfData) so there r two cases for functions whether we should import them by ordinal or by names lets start with ordinal\nwe do the following pick the origThunk-\u0026gt;u1.Ordinal and (and \u0026amp;) it with IMAGE_ORDINAL_FLAG64 which is 0x8000000000000000 in x64 what this does is check if the ordinal bit is set if true then we need to import by ordinal to do so we extract the ordinal by again using the \u0026amp; operator with the ordinal WORD ordinal = (WORD)(origThunk-\u0026gt;u1.Ordinal \u0026amp; 0xFFFF); this way we extract the ordinal only finally we get the address funcAddress = GetProcAddress(dllHandle, (LPCSTR)(uintptr_t)ordinal);\nnow for imports by name we need to first get the structure PIMAGE_IMPORT_BY_NAME importByName = (PIMAGE_IMPORT_BY_NAME)(BaseAddress + origThunk-\u0026gt;u1.AddressOfData); then we have the name char* funcName = (char*)importByName-\u0026gt;Name; all we need to do is get the address with funcAddress = GetProcAddress(dllHandle, funcName);\nfor the final step which we did all of this for we need to patch the iat table first we need its address first we calculate the offset using ULONGLONG offset = (BYTE*)firstThunk - (BYTE*)BaseAddress; this gives us the offset of the entry inside the iat table we can get this from our process since we have the offset we just add it to the remote base ULONGLONG remoteIATEntry = (ULONGLONG)RemoteAddress + offset; finally we path the iat table using WriteProcessMemmory()\nand thats it now the iat table is patched and the imports are resolved\nFULL CODE :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 if (ntHeader-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress != 0) { DWORD importRVA = ntHeader-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; DWORD importSize = ntHeader-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size; IMAGE_IMPORT_DESCRIPTOR* importDesc = (PIMAGE_IMPORT_DESCRIPTOR)(BaseAddress + ntHeader-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); SIZE_T descriptorSize = sizeof(IMAGE_IMPORT_DESCRIPTOR); PIMAGE_IMPORT_DESCRIPTOR currentDesc = importDesc; while (currentDesc-\u0026gt;Name) { const char* dllName = (char*)(BaseAddress + currentDesc-\u0026gt;Name); HMODULE dllHandle = GetModuleHandleA(dllName); if (!dllHandle) dllHandle = LoadLibraryA(dllName); PIMAGE_THUNK_DATA origThunk = (PIMAGE_THUNK_DATA)(BaseAddress + currentDesc-\u0026gt;OriginalFirstThunk); PIMAGE_THUNK_DATA firstThunk = (PIMAGE_THUNK_DATA)(BaseAddress + currentDesc-\u0026gt;FirstThunk); while (origThunk-\u0026gt;u1.AddressOfData) { FARPROC funcAddress = NULL; if (origThunk-\u0026gt;u1.Ordinal \u0026amp; IMAGE_ORDINAL_FLAG64) { WORD ordinal = (WORD)(origThunk-\u0026gt;u1.Ordinal \u0026amp; 0xFFFF); funcAddress = GetProcAddress(dllHandle, (LPCSTR)(uintptr_t)ordinal); } else { PIMAGE_IMPORT_BY_NAME importByName = (PIMAGE_IMPORT_BY_NAME)(BaseAddress + origThunk-\u0026gt;u1.AddressOfData); char* funcName = (char*)importByName-\u0026gt;Name; funcAddress = GetProcAddress(dllHandle, funcName); } ULONGLONG remoteIATEntry = (ULONGLONG)NewAddress + ((BYTE*)firstThunk - (BYTE*)BaseAddress); SIZE_T bytesWritten1 = 0; if (!WriteProcessMemory(pi.hProcess, (LPVOID)remoteIATEntry, \u0026amp;funcAddress, sizeof(funcAddress), \u0026amp;bytesWritten1)) { error(\u0026#34;Failed to write to remote IAT\u0026#34;); return -1; } origThunk++; firstThunk++; } currentDesc++; } } ","date":"2025-07-22T00:00:00Z","image":"https://B4shCr00k.github.io/0xTheAbYss/posts/resolving-imports-remotely/nice_hu_69704fb005500857.jpg","permalink":"https://B4shCr00k.github.io/0xTheAbYss/posts/resolving-imports-remotely/","title":"Resolving Imports Remotely"}]